// SPDX-License-Identifier: GPL-2.0
/*
 * AR2020 driver for Raspberry Pi Compute Module 4
 * Based on Rockchip AR2020 driver, adapted for Broadcom BCM2711
 */

#include <linux/clk.h>
#include <linux/device.h>
#include <linux/delay.h>
#include <linux/gpio/consumer.h>
#include <linux/i2c.h>
#include <linux/module.h>
#include <linux/pm_runtime.h>
#include <linux/regulator/consumer.h>
#include <linux/sysfs.h>
#include <linux/slab.h>
#include <linux/version.h>
#include <media/v4l2-subdev.h>
#include <media/v4l2-ctrls.h>
#include <media/media-entity.h>
#include <linux/of.h>
#include <linux/of_device.h>
#include <linux/of_gpio.h>

#define V4L2_CID_USER_AR2020_BASE        (V4L2_CID_USER_BASE + 0x2000)
#define V4L2_CID_AR2020_SET_REGISTER     (V4L2_CID_USER_AR2020_BASE + 0)
#define V4L2_CID_AR2020_CLEAR_CUSTOM_REGS (V4L2_CID_USER_AR2020_BASE + 1)

#define BAYER_CFA                   "bggr"
#define DRIVER_VERSION			    KERNEL_VERSION(0, 0x01, 0x02) // Cập nhật phiên bản
#define AR2020_NAME			        "ar2020"
#define AR2020_LANES			    2
#define AR2020_BPP			        10 // RAW10
#define MIPI_FREQ_720M              720000000ULL // MIPI clock 600 MHz
#define PIXEL_RATE			        (MIPI_FREQ_720M / AR2020_BPP * AR2020_LANES)
#define AR2020_XVCLK_FREQ		    27000000 // Cập nhật thành 27 MHz

#define CHIP_ID				        0x0653
#define AR2020_REG_CHIP_ID		    0x0016
#define AR2020_REG_CTRL_MODE		0x0100
#define AR2020_MODE_SW_STANDBY		0x00
#define AR2020_MODE_STREAMING		0x01
#define AR2020_REG_EXP			    0x0202
#define AR2020_REG_GAIN			    0x3062
#define AR2020_REG_VTS			    0x0340
#define AR2020_REG_SOFTWARE_RESET	0x0103

#define AR2020_EXPOSURE_MIN		    2
#define AR2020_EXPOSURE_STEP		1
#define AR2020_VTS_MAX			    0xFFFF
#define AR2020_GAIN_MIN			    0
#define AR2020_GAIN_MAX			    127
#define AR2020_GAIN_STEP		    1
#define AR2020_GAIN_DEFAULT		    0x20

#define REG_NULL			        0xFFFF
#define REG_DELAY			        0xFFFE
#define AR2020_REG_VALUE_08BIT		1
#define AR2020_REG_VALUE_16BIT		2

static const char * const ar2020_supply_names[] = {
    "avdd",  // 2.8V
    "dovdd", // 1.8V
    "dvdd",  // 1.2V
};
#define AR2020_NUM_SUPPLIES		ARRAY_SIZE(ar2020_supply_names)

#define AR2020_MAX_CUSTOM_REGS       32

/* Structure for custom register settings via V4L2 control */
struct ar2020_custom_reg {
    u16 addr;    /* Register address */
    u16 val;     /* Register value */
    u8 bits;     /* Bit width (8 or 16) */
    bool enabled; /* Whether this register is set */
};

struct regval {
    u16 addr;
    u16 val;
    u8 bits;
};

struct ar2020_mode {
    u32 width;
    u32 height;
    struct v4l2_fract max_fps;
    u32 hts_def;
    u32 vts_def;
    u32 exp_def;
    const struct regval *reg_list;
};

struct ar2020 {
    struct i2c_client *client;
    struct clk *xvclk;
    struct gpio_desc *reset_gpio;
    struct gpio_desc *pwdn_gpio;
    struct regulator_bulk_data supplies[AR2020_NUM_SUPPLIES];
    struct v4l2_subdev subdev;
    struct media_pad pad;
    struct v4l2_ctrl_handler ctrl_handler;
    struct v4l2_ctrl *exposure;
    struct v4l2_ctrl *anal_gain;
    struct v4l2_ctrl *vblank;
    struct v4l2_ctrl *hblank;
    struct v4l2_ctrl *pixel_rate;
    struct v4l2_ctrl *test_pattern; 
    struct v4l2_ctrl *custom_regs; /* New control for custom registers */
    struct v4l2_ctrl *clear_custom_regs;
    struct ar2020_custom_reg custom_regs_array[AR2020_MAX_CUSTOM_REGS]; /* Storage for custom registers */ 
    struct mutex mutex;
    bool streaming;
    const struct ar2020_mode *cur_mode;
};

#define to_ar2020(sd) container_of(sd, struct ar2020, subdev)

static const struct regval MIPI_2lane__5120x3840_Linear_7p5fps[] = {
    { 0x0100, 0x0000, AR2020_REG_VALUE_16BIT },
    // { REG_DELAY, 1000,   AR2020_REG_VALUE_16BIT },

    /* --- PLL VT (Video Timing) EXTCLK = 27 MHz 171.75MHz--- */
    { 0x0304, 0x0006, AR2020_REG_VALUE_16BIT },    /* [0x0304] VT_PRE_PLL_CLK_DIV = 0x09 */
    { 0x0306, 0x00E5, AR2020_REG_VALUE_16BIT },    /* [0x0306] VT_PLL_MULTIPLIER = 0x0190  (400 decimal) */
    { 0x0300, 0x0006, AR2020_REG_VALUE_16BIT },    /* [0x0300] VT_PIX_CLK_DIV = 0x07 */
    { 0x0302, 0x0001, AR2020_REG_VALUE_16BIT },    /* [0x0302] VT_SYS_CLK_DIV = 0x01 */

    /* --- PLL OP (Output Path) OP_PIX = 60 MHz --- */
    // { 0x030C, 0x0009, AR2020_REG_VALUE_16BIT },    /* [0x030C] OP_PRE_PLL_CLK_DIV = 0x03 */
    // { 0x030E, 0x00C8, AR2020_REG_VALUE_16BIT },    /* [0x030E] OP_PLL_MULTIPLIER = 0x0050  (80 decimal) */
    // { 0x0308, 0x0005, AR2020_REG_VALUE_16BIT },    /* [0x0308] OP_PIX_CLK_DIV = 0x09 */
    // { 0x030A, 0x0002, AR2020_REG_VALUE_16BIT },    /* [0x030A] OP_SYS_CLK_DIV = 0x01 */

    // {0x0112, 0x0A0A, AR2020_REG_VALUE_16BIT},  /* CSI_DATA_FORMAT = 0x0A */
    // {0x0114, 0x0001, AR2020_REG_VALUE_08BIT}, /* CSI_LANE_MODE = 0x01 */
    // {0x0300, 0x0006, AR2020_REG_VALUE_16BIT},  /* VT_PIX_CLK_DIV = 0x0006 */
    // {0x0302, 0x0001, AR2020_REG_VALUE_16BIT},  /* VT_SYS_CLK_DIV = 0x0001 */
    // {0x0304, 0x0006, AR2020_REG_VALUE_16BIT}, /* VT_PRE_PLL_CLK_DIV = 0x0006 */
    // {0x0306, 0x00E5, AR2020_REG_VALUE_16BIT}, /* VT_PLL_MULTIPLIER = 0x00E5 */
    {0x0308, 0x0005, AR2020_REG_VALUE_16BIT}, /* OP_PIX_CLK_DIV = 0x0005 */
    {0x030A, 0x0002, AR2020_REG_VALUE_16BIT}, /* OP_SYS_CLK_DIV = 0x0002 */
    {0x030C, 0x0007, AR2020_REG_VALUE_16BIT}, /* OP_PRE_PLL_CLK_DIV = 0x0007 */
    {0x030E, 0x009B, AR2020_REG_VALUE_16BIT}, /* OP_PLL_MULTIPLIER = 0x009B */
    
    {0x0340, 0x1BC4, AR2020_REG_VALUE_16BIT}, /* FRAME_LENGTH_LINES = 0x1BC4 */
    {0x0342, 0xFFF0, AR2020_REG_VALUE_16BIT}, /* LINE_LENGTH_PCK = 0xFFF0 */
    
    // {0x0348, 0x1407, AR2020_REG_VALUE_16BIT}, /* X_ADDR_END = 0x0F07 */
    // {0x034A, 0x0F07, AR2020_REG_VALUE_16BIT}, /* Y_ADDR_END = 0x0877 */
    // {0x0344, 0x0008, AR2020_REG_VALUE_16BIT}, /* X_ADDR_START = 8 */
    // {0x0346, 0x0008, AR2020_REG_VALUE_16BIT}, /* Y_ADDR_START = 8 */

    {0x3EC8, 0x0000, AR2020_REG_VALUE_16BIT},  /* X_OUTPUT_OFFSET = 0x0000 */
    {0x3ECA, 0x0000, AR2020_REG_VALUE_16BIT},  /* Y_OUTPUT_OFFSET = 0x0000 */
    // {0x034C, 0x1400, AR2020_REG_VALUE_16BIT},  /* X_OUTPUT_SIZE = 0x0F00 (3840) */
    // {0x034E, 0x0F00, AR2020_REG_VALUE_16BIT},  /* Y_OUTPUT_SIZE = 0x0870 (2160) */

    
    {0x3F18, 0x7B70, AR2020_REG_VALUE_16BIT}, /* MIPI_JPEG_PN9_DATA_TYPE = 0x7B70 */
    {0x3F20, 0x8000, AR2020_REG_VALUE_16BIT}, /* MIPI_PHY_TRIM_MSB = 0x8000 */

    { 0x0344, 0x0008, AR2020_REG_VALUE_16BIT },    /* [0x0344] X_ADDR_START = 0x0008 */
    { 0x0348, 0x1407, AR2020_REG_VALUE_16BIT },    /* [0x0348] X_ADDR_END   = 0x1407 */ 
    { 0x0346, 0x0008, AR2020_REG_VALUE_16BIT },    /* [0x0346] Y_ADDR_START = 0x0008 */
    { 0x034A, 0x0F07, AR2020_REG_VALUE_16BIT },    /* [0x034A] Y_ADDR_END   = 0x0F07 */
    { 0x034C, 0x1400, AR2020_REG_VALUE_16BIT },    /* [0x034C] X_OUTPUT_SIZE = 0x1400 (5120) */
    { 0x034E, 0x0F00, AR2020_REG_VALUE_16BIT },    /* [0x034E] Y_OUTPUT_SIZE = 0x0F00 (3840) */

    { 0x0380, 0x0001, AR2020_REG_VALUE_16BIT },    /* [0x0380] X_EVEN_INC = 0x01 */
    { 0x0382, 0x0001, AR2020_REG_VALUE_16BIT },    /* [0x0382] X_ODD_INC  = 0x01 */
    { 0x0384, 0x0001, AR2020_REG_VALUE_16BIT },    /* [0x0384] Y_EVEN_INC = 0x01 */
    { 0x0386, 0x0001, AR2020_REG_VALUE_16BIT },    /* [0x0386] Y_ODD_INC  = 0x01 */

    { 0x0900, 0x0000, AR2020_REG_VALUE_16BIT },    /* [0x0900] BINNING_MODE = 0x00 */               
    { 0x0901, 0x0011, AR2020_REG_VALUE_16BIT },    /* [0x0901] BINNING_TYPE = 0x11 */               

    // { 0x0342, 0xAF00, AR2020_REG_VALUE_16BIT },    /* [0x0342] LINE_LENGTH_PCK   = 0xAF00 (44800) */
    // { 0x0340, 0x0F1E, AR2020_REG_VALUE_16BIT },    /* [0x0340] FRAME_LENGTH_LINES = 0x0F1E (3870) */

    // /* --- Thời gian phơi sáng cơ bản (Integration) --- */
    // { 0x0202, 0x0003, AR2020_REG_VALUE_16BIT },    /* [0x0202] COARSE_INTEGRATION_TIME = 0x0003 */
    // { 0x0202, 0x0067, AR2020_REG_VALUE_16BIT },    /* [0x0202] COARSE_INTEGRATION_TIME = 0x0003 */
    // { 0x0202, 0x0240, AR2020_REG_VALUE_16BIT },    /* [0x0202] COARSE_INTEGRATION_TIME = 0x0003 */                /*<- Expose time set */
    // { 0x3062, 0x0000, AR2020_REG_VALUE_16BIT }                                                                    /*<- Expose time set */

    { 0x0112, 0x0A0A, AR2020_REG_VALUE_16BIT },    /* [0x0112] CSI_DATA_FORMAT = 0x0A0A */
    { 0x0114, 0x0001, AR2020_REG_VALUE_08BIT },    /* [0x0114] CSI_LANE_MODE   = 0x0001 */

    // { 0x0800, 0x000D, AR2020_REG_VALUE_16BIT },    /* [0x0800] TCLK_POST    = 0x000D */
    // { 0x0801, 0x0006, AR2020_REG_VALUE_16BIT },    /* [0x0801] THS_PREPARE  = 0x0006 */
    // { 0x0802, 0x000A, AR2020_REG_VALUE_16BIT },    /* [0x0802] THS_ZERO_MIN = 0x000A */
    // { 0x0803, 0x0008, AR2020_REG_VALUE_16BIT },    /* [0x0803] THS_TRAIL    = 0x0008 */
    // { 0x0804, 0x0009, AR2020_REG_VALUE_16BIT },    /* [0x0804] TCLK_TRAIL_MIN = 0x0009 */
    // { 0x0805, 0x0005, AR2020_REG_VALUE_16BIT },    /* [0x0805] TCLK_PREPARE   = 0x0005 */
    // { 0x0806, 0x001E, AR2020_REG_VALUE_16BIT },    /* [0x0806] TCLK_ZERO      = 0x001E */
    // { 0x0807, 0x0006, AR2020_REG_VALUE_16BIT },    /* [0x0807] TLPX           = 0x0006 */

    // { 0x082A, 0x000D, AR2020_REG_VALUE_16BIT },    /* [0x082A] TWAKEUP = 0x000D */
    // { 0x082B, 0x000A, AR2020_REG_VALUE_16BIT },    /* [0x082B] TINIT   = 0x000A */
    // { 0x082C, 0x000B, AR2020_REG_VALUE_16BIT },    /* [0x082C] THS_EXIT = 0x000B */

    /* --- MIPI PHY (boost, trim) --- */
    // { 0x3F06, 0x00C0, AR2020_REG_VALUE_16BIT },    /* [0x3F06] MIPI_TIMING_2 = 0x00C0 */
    // { 0x3F0A, 0xA000, AR2020_REG_VALUE_16BIT },    /* [0x3F0A] MIPI_TIMING_4 = 0xA000 */
    // { 0x3F0C, 0x0007, AR2020_REG_VALUE_16BIT },    /* [0x3F0C] MIPI_TIMING_5 = 0x0007 */
    // { 0x3F20, 0x8008, AR2020_REG_VALUE_16BIT },    /* [0x3F20] MIPI_PHY_TRIM_MSB = 0x8008 */
    // { 0x3F1E, 0x0000, AR2020_REG_VALUE_16BIT },    /* [0x3F1E] MIPI_PHY_TRIM_LSB = 0x0000 */

    
    // /* --- GAIN TABLE LINEAR REV1--- */
    // /* --- GAIN TABLE LINEAR REV1--- */
    // /* --- GAIN TABLE LINEAR REV1--- */
    { 0x5500, 0x0000, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5500 = 0x0   */
    { 0x5502, 0x0002, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5502 = 0x2   */
    { 0x5504, 0x0006, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5504 = 0x6   */
    { 0x5506, 0x0009, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5506 = 0x9   */
    { 0x5508, 0x000F, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5508 = 0xF   */
    { 0x550A, 0x0010, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_550A = 0x10  */
    { 0x550C, 0x0011, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_550C = 0x11  */
    { 0x550E, 0x0012, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_550E = 0x12  */
    { 0x5510, 0x0019, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5510 = 0x19  */
    { 0x5512, 0x0020, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5512 = 0x20  */
    { 0x5514, 0x0021, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5514 = 0x21  */
    { 0x5516, 0x0023, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5516 = 0x23  */
    { 0x5518, 0x0026, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5518 = 0x26  */
    { 0x551A, 0x002B, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_551A = 0x2B  */
    { 0x551C, 0x002F, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_551C = 0x2F  */
    { 0x551E, 0x0030, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_551E = 0x30  */

    { 0x5400, 0x0100, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5400 = 0x0100  */
    { 0x5402, 0x2106, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5402 = 0x2106  */
    { 0x5404, 0x1101, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5404 = 0x1101  */
    { 0x5406, 0x3106, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5406 = 0x3106  */
    { 0x5408, 0x7100, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5408 = 0x7100  */
    { 0x540A, 0x8107, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_540A = 0x8107  */
    { 0x540C, 0xB101, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_540C = 0xB101  */
    { 0x540E, 0xD101, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_540E = 0xD101  */
    { 0x5410, 0xF12E, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5410 = 0xF12E  */
    { 0x5412, 0xF112, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5412 = 0xF112  */
    { 0x5414, 0xF184, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5414 = 0xF184  */
    { 0x5416, 0xF224, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5416 = 0xF224  */
    { 0x5418, 0xF306, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5418 = 0xF306  */
    { 0x541A, 0xF446, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_541A = 0xF446  */
    { 0x541C, 0xF609, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_541C = 0xF609  */
    { 0x541E, 0xF887, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_541E = 0xF887  */
    { 0x5420, 0xFC0B, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5420 = 0xFC0B  */
    { 0x5422, 0xFC0B, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5422 = 0xFC0B  */
    { 0x5424, 0xFFFA, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5424 = 0xFFFA  */
    { 0x5426, 0x5557, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5426 = 0x5557  */
    { 0x5428, 0x0005, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5428 = 0x0005  */
    { 0x542A, 0xA550, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_542A = 0xA550  */
    { 0x542C, 0xAAAA, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_542C = 0xAAAA  */
    { 0x542E, 0x000A, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_542E = 0x000A  */

    { 0x5460, 0x2269, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5460 = 0x2269  */
    { 0x5462, 0x0B87, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5462 = 0x0B87  */
    { 0x5464, 0x0B87, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5464 = 0x0B87  */
    { 0x5466, 0x0983, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5466 = 0x0983  */

    { 0x5498, 0x225E, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_5498 = 0x225E  */
    { 0x549A, 0xBCAA, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_549A = 0xBCAA  */
    { 0x549C, 0xBCAA, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_549C = 0xBCAA  */
    { 0x549E, 0xBDAA, AR2020_REG_VALUE_16BIT },  /* reserved_mfr_549E = 0xBDAA  */

    /* [0x3060] GAIN_TABLE_CTRL = 0xFF01 */
    { 0x3060, 0xFF01, AR2020_REG_VALUE_16BIT },  /* gain_table_ctrl = 0xFF01  */
    /* --- END GAIN TABLE--- */
    { REG_DELAY, 1000,   AR2020_REG_VALUE_16BIT },
    /* --- TIMING ANALOG RECOMMEND POR --- */
    /* --- TIMING ANALOG RECOMMEND POR --- */
    /* --- TIMING ANALOG RECOMMEND POR --- */
    {0x4000, 0x0114, AR2020_REG_VALUE_16BIT},
    {0x4002, 0x1A25, AR2020_REG_VALUE_16BIT},
    {0x4004, 0x3DFF, AR2020_REG_VALUE_16BIT},
    {0x4006, 0xFFFF, AR2020_REG_VALUE_16BIT},
    {0x4008, 0x0A35, AR2020_REG_VALUE_16BIT},
    {0x400A, 0x10EF, AR2020_REG_VALUE_16BIT},
    {0x400C, 0x3003, AR2020_REG_VALUE_16BIT},
    {0x400E, 0x30D8, AR2020_REG_VALUE_16BIT},
    {0x4010, 0xF003, AR2020_REG_VALUE_16BIT},
    {0x4012, 0xB5F0, AR2020_REG_VALUE_16BIT},
    {0x4014, 0x0085, AR2020_REG_VALUE_16BIT},
    {0x4016, 0xF004, AR2020_REG_VALUE_16BIT},
    {0x4018, 0x9A89, AR2020_REG_VALUE_16BIT},
    {0x401A, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x401C, 0x9997, AR2020_REG_VALUE_16BIT},
    {0x401E, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x4020, 0x30C0, AR2020_REG_VALUE_16BIT},
    {0x4022, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x4024, 0x82F0, AR2020_REG_VALUE_16BIT},
    {0x4026, 0x0030, AR2020_REG_VALUE_16BIT},
    {0x4028, 0x18F0, AR2020_REG_VALUE_16BIT},
    {0x402A, 0x0320, AR2020_REG_VALUE_16BIT},
    {0x402C, 0x58F0, AR2020_REG_VALUE_16BIT},
    {0x402E, 0x089C, AR2020_REG_VALUE_16BIT},
    {0x4030, 0xF010, AR2020_REG_VALUE_16BIT},
    {0x4032, 0x99B6, AR2020_REG_VALUE_16BIT},
    {0x4034, 0xF003, AR2020_REG_VALUE_16BIT},
    {0x4036, 0xB498, AR2020_REG_VALUE_16BIT},
    {0x4038, 0xA096, AR2020_REG_VALUE_16BIT},
    {0x403A, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x403C, 0xA2F0, AR2020_REG_VALUE_16BIT},
    {0x403E, 0x00A2, AR2020_REG_VALUE_16BIT},
    {0x4040, 0xF008, AR2020_REG_VALUE_16BIT},
    {0x4042, 0x9DF0, AR2020_REG_VALUE_16BIT},
    {0x4044, 0x209D, AR2020_REG_VALUE_16BIT},
    {0x4046, 0x8C08, AR2020_REG_VALUE_16BIT},
    {0x4048, 0x08F0, AR2020_REG_VALUE_16BIT},
    {0x404A, 0x0036, AR2020_REG_VALUE_16BIT},
    {0x404C, 0x008F, AR2020_REG_VALUE_16BIT},
    {0x404E, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x4050, 0x88F0, AR2020_REG_VALUE_16BIT},
    {0x4052, 0x0488, AR2020_REG_VALUE_16BIT},
    {0x4054, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x4056, 0x3600, AR2020_REG_VALUE_16BIT},
    {0x4058, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x405A, 0x83F0, AR2020_REG_VALUE_16BIT},
    {0x405C, 0x0290, AR2020_REG_VALUE_16BIT},
    {0x405E, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x4060, 0x8BF0, AR2020_REG_VALUE_16BIT},
    {0x4062, 0x2EA3, AR2020_REG_VALUE_16BIT},
    {0x4064, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x4066, 0xA3F0, AR2020_REG_VALUE_16BIT},
    {0x4068, 0x089D, AR2020_REG_VALUE_16BIT},
    {0x406A, 0xF075, AR2020_REG_VALUE_16BIT},
    {0x406C, 0x3003, AR2020_REG_VALUE_16BIT},
    {0x406E, 0x4070, AR2020_REG_VALUE_16BIT},
    {0x4070, 0x216D, AR2020_REG_VALUE_16BIT},
    {0x4072, 0x1CF6, AR2020_REG_VALUE_16BIT},
    {0x4074, 0x8B00, AR2020_REG_VALUE_16BIT},
    {0x4076, 0x5186, AR2020_REG_VALUE_16BIT},
    {0x4078, 0x1300, AR2020_REG_VALUE_16BIT},
    {0x407A, 0x0205, AR2020_REG_VALUE_16BIT},
    {0x407C, 0x36D8, AR2020_REG_VALUE_16BIT},
    {0x407E, 0xF002, AR2020_REG_VALUE_16BIT},
    {0x4080, 0x8387, AR2020_REG_VALUE_16BIT},
    {0x4082, 0xF006, AR2020_REG_VALUE_16BIT},
    {0x4084, 0x8702, AR2020_REG_VALUE_16BIT},
    {0x4086, 0x0D02, AR2020_REG_VALUE_16BIT},
    {0x4088, 0x05F0, AR2020_REG_VALUE_16BIT},
    {0x408A, 0x0383, AR2020_REG_VALUE_16BIT},
    {0x408C, 0xF001, AR2020_REG_VALUE_16BIT},
    {0x408E, 0x87F0, AR2020_REG_VALUE_16BIT},
    {0x4090, 0x0213, AR2020_REG_VALUE_16BIT},
    {0x4092, 0x0036, AR2020_REG_VALUE_16BIT},
    {0x4094, 0xD887, AR2020_REG_VALUE_16BIT},
    {0x4096, 0x020D, AR2020_REG_VALUE_16BIT},
    {0x4098, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x409A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x409C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x409E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x40A0, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x40A2, 0x0401, AR2020_REG_VALUE_16BIT},
    {0x40A4, 0xF008, AR2020_REG_VALUE_16BIT},
    {0x40A6, 0x82F0, AR2020_REG_VALUE_16BIT},
    {0x40A8, 0x0883, AR2020_REG_VALUE_16BIT},
    {0x40AA, 0xF009, AR2020_REG_VALUE_16BIT},
    {0x40AC, 0x85F0, AR2020_REG_VALUE_16BIT},
    {0x40AE, 0x2985, AR2020_REG_VALUE_16BIT},
    {0x40B0, 0x87F0, AR2020_REG_VALUE_16BIT},
    {0x40B2, 0x2A87, AR2020_REG_VALUE_16BIT},
    {0x40B4, 0xF63E, AR2020_REG_VALUE_16BIT},
    {0x40B6, 0x88F0, AR2020_REG_VALUE_16BIT},
    {0x40B8, 0x0801, AR2020_REG_VALUE_16BIT},
    {0x40BA, 0x40F0, AR2020_REG_VALUE_16BIT},
    {0x40BC, 0x0800, AR2020_REG_VALUE_16BIT},
    {0x40BE, 0x48F0, AR2020_REG_VALUE_16BIT},
    {0x40C0, 0x0882, AR2020_REG_VALUE_16BIT},
    {0x40C2, 0xF008, AR2020_REG_VALUE_16BIT},
    {0x40C4, 0x0401, AR2020_REG_VALUE_16BIT},
    {0x40C6, 0xF008, AR2020_REG_VALUE_16BIT},
    {0x40C8, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x40CA, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x40CC, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x40CE, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x40D0, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x40D2, 0x0401, AR2020_REG_VALUE_16BIT},
    {0x40D4, 0xF015, AR2020_REG_VALUE_16BIT},
    {0x40D6, 0x002C, AR2020_REG_VALUE_16BIT},
    {0x40D8, 0xF00E, AR2020_REG_VALUE_16BIT},
    {0x40DA, 0x85F0, AR2020_REG_VALUE_16BIT},
    {0x40DC, 0x0687, AR2020_REG_VALUE_16BIT},
    {0x40DE, 0xF002, AR2020_REG_VALUE_16BIT},
    {0x40E0, 0x87F0, AR2020_REG_VALUE_16BIT},
    {0x40E2, 0x61E8, AR2020_REG_VALUE_16BIT},
    {0x40E4, 0x3900, AR2020_REG_VALUE_16BIT},
    {0x40E6, 0xF005, AR2020_REG_VALUE_16BIT},
    {0x40E8, 0x3480, AR2020_REG_VALUE_16BIT},
    {0x40EA, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x40EC, 0x3240, AR2020_REG_VALUE_16BIT},
    {0x40EE, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x40F0, 0x3900, AR2020_REG_VALUE_16BIT},
    {0x40F2, 0xF00E, AR2020_REG_VALUE_16BIT},
    {0x40F4, 0x3900, AR2020_REG_VALUE_16BIT},
    {0x40F6, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x40F8, 0x3240, AR2020_REG_VALUE_16BIT},
    {0x40FA, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x40FC, 0x3480, AR2020_REG_VALUE_16BIT},
    {0x40FE, 0xF005, AR2020_REG_VALUE_16BIT},
    {0x4100, 0xC0E6, AR2020_REG_VALUE_16BIT},
    {0x4102, 0xF004, AR2020_REG_VALUE_16BIT},
    {0x4104, 0x3900, AR2020_REG_VALUE_16BIT},
    {0x4106, 0xF003, AR2020_REG_VALUE_16BIT},
    {0x4108, 0xB0F0, AR2020_REG_VALUE_16BIT},
    {0x410A, 0x0083, AR2020_REG_VALUE_16BIT},
    {0x410C, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x410E, 0x86F0, AR2020_REG_VALUE_16BIT},
    {0x4110, 0x0086, AR2020_REG_VALUE_16BIT},
    {0x4112, 0xF089, AR2020_REG_VALUE_16BIT},
    {0x4114, 0xB0F0, AR2020_REG_VALUE_16BIT},
    {0x4116, 0x00E9, AR2020_REG_VALUE_16BIT},
    {0x4118, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x411A, 0x8AF0, AR2020_REG_VALUE_16BIT},
    {0x411C, 0x0000, AR2020_REG_VALUE_16BIT},
    {0x411E, 0x05F0, AR2020_REG_VALUE_16BIT},
    {0x4120, 0x00E0, AR2020_REG_VALUE_16BIT},
    {0x4122, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4124, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4126, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4128, 0x0A35, AR2020_REG_VALUE_16BIT},
    {0x412A, 0x10EF, AR2020_REG_VALUE_16BIT},
    {0x412C, 0x3003, AR2020_REG_VALUE_16BIT},
    {0x412E, 0x30D8, AR2020_REG_VALUE_16BIT},
    {0x4130, 0xF005, AR2020_REG_VALUE_16BIT},
    {0x4132, 0x85F0, AR2020_REG_VALUE_16BIT},
    {0x4134, 0x049A, AR2020_REG_VALUE_16BIT},
    {0x4136, 0x89F0, AR2020_REG_VALUE_16BIT},
    {0x4138, 0x0099, AR2020_REG_VALUE_16BIT},
    {0x413A, 0x97F0, AR2020_REG_VALUE_16BIT},
    {0x413C, 0x0030, AR2020_REG_VALUE_16BIT},
    {0x413E, 0xC0F0, AR2020_REG_VALUE_16BIT},
    {0x4140, 0x0082, AR2020_REG_VALUE_16BIT},
    {0x4142, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x4144, 0x3018, AR2020_REG_VALUE_16BIT},
    {0x4146, 0xF002, AR2020_REG_VALUE_16BIT},
    {0x4148, 0xB520, AR2020_REG_VALUE_16BIT},
    {0x414A, 0x58F0, AR2020_REG_VALUE_16BIT},
    {0x414C, 0x089C, AR2020_REG_VALUE_16BIT},
    {0x414E, 0xF010, AR2020_REG_VALUE_16BIT},
    {0x4150, 0x99B6, AR2020_REG_VALUE_16BIT},
    {0x4152, 0xF003, AR2020_REG_VALUE_16BIT},
    {0x4154, 0xB498, AR2020_REG_VALUE_16BIT},
    {0x4156, 0xA096, AR2020_REG_VALUE_16BIT},
    {0x4158, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x415A, 0xA2F0, AR2020_REG_VALUE_16BIT},
    {0x415C, 0x00A2, AR2020_REG_VALUE_16BIT},
    {0x415E, 0xF008, AR2020_REG_VALUE_16BIT},
    {0x4160, 0x9DF0, AR2020_REG_VALUE_16BIT},
    {0x4162, 0x209D, AR2020_REG_VALUE_16BIT},
    {0x4164, 0x8C08, AR2020_REG_VALUE_16BIT},
    {0x4166, 0x08F0, AR2020_REG_VALUE_16BIT},
    {0x4168, 0x0036, AR2020_REG_VALUE_16BIT},
    {0x416A, 0x008F, AR2020_REG_VALUE_16BIT},
    {0x416C, 0x88F0, AR2020_REG_VALUE_16BIT},
    {0x416E, 0x0188, AR2020_REG_VALUE_16BIT},
    {0x4170, 0x3600, AR2020_REG_VALUE_16BIT},
    {0x4172, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x4174, 0x83F0, AR2020_REG_VALUE_16BIT},
    {0x4176, 0x0290, AR2020_REG_VALUE_16BIT},
    {0x4178, 0xF001, AR2020_REG_VALUE_16BIT},
    {0x417A, 0x8BF0, AR2020_REG_VALUE_16BIT},
    {0x417C, 0x2DA3, AR2020_REG_VALUE_16BIT},
    {0x417E, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x4180, 0xA3F0, AR2020_REG_VALUE_16BIT},
    {0x4182, 0x089D, AR2020_REG_VALUE_16BIT},
    {0x4184, 0xF06D, AR2020_REG_VALUE_16BIT},
    {0x4186, 0x4070, AR2020_REG_VALUE_16BIT},
    {0x4188, 0x3003, AR2020_REG_VALUE_16BIT},
    {0x418A, 0x214D, AR2020_REG_VALUE_16BIT},
    {0x418C, 0x1FF6, AR2020_REG_VALUE_16BIT},
    {0x418E, 0x0851, AR2020_REG_VALUE_16BIT},
    {0x4190, 0x0245, AR2020_REG_VALUE_16BIT},
    {0x4192, 0x9D36, AR2020_REG_VALUE_16BIT},
    {0x4194, 0xD8F0, AR2020_REG_VALUE_16BIT},
    {0x4196, 0x0083, AR2020_REG_VALUE_16BIT},
    {0x4198, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x419A, 0x87F0, AR2020_REG_VALUE_16BIT},
    {0x419C, 0x0087, AR2020_REG_VALUE_16BIT},
    {0x419E, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x41A0, 0x36D8, AR2020_REG_VALUE_16BIT},
    {0x41A2, 0x020D, AR2020_REG_VALUE_16BIT},
    {0x41A4, 0x0205, AR2020_REG_VALUE_16BIT},
    {0x41A6, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x41A8, 0x36D8, AR2020_REG_VALUE_16BIT},
    {0x41AA, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x41AC, 0x83F0, AR2020_REG_VALUE_16BIT},
    {0x41AE, 0x0087, AR2020_REG_VALUE_16BIT},
    {0x41B0, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x41B2, 0x87F0, AR2020_REG_VALUE_16BIT},
    {0x41B4, 0x0036, AR2020_REG_VALUE_16BIT},
    {0x41B6, 0xD802, AR2020_REG_VALUE_16BIT},
    {0x41B8, 0x0D02, AR2020_REG_VALUE_16BIT},
    {0x41BA, 0x05F0, AR2020_REG_VALUE_16BIT},
    {0x41BC, 0x0036, AR2020_REG_VALUE_16BIT},
    {0x41BE, 0xD8F0, AR2020_REG_VALUE_16BIT},
    {0x41C0, 0x0083, AR2020_REG_VALUE_16BIT},
    {0x41C2, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x41C4, 0x87F0, AR2020_REG_VALUE_16BIT},
    {0x41C6, 0x0087, AR2020_REG_VALUE_16BIT},
    {0x41C8, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x41CA, 0x36D8, AR2020_REG_VALUE_16BIT},
    {0x41CC, 0x020D, AR2020_REG_VALUE_16BIT},
    {0x41CE, 0x0205, AR2020_REG_VALUE_16BIT},
    {0x41D0, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x41D2, 0x36D8, AR2020_REG_VALUE_16BIT},
    {0x41D4, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x41D6, 0x83F0, AR2020_REG_VALUE_16BIT},
    {0x41D8, 0x0087, AR2020_REG_VALUE_16BIT},
    {0x41DA, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x41DC, 0x8713, AR2020_REG_VALUE_16BIT},
    {0x41DE, 0x0036, AR2020_REG_VALUE_16BIT},
    {0x41E0, 0xD802, AR2020_REG_VALUE_16BIT},
    {0x41E2, 0x0DE0, AR2020_REG_VALUE_16BIT},
    {0x41E4, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x41E6, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x41E8, 0x9F13, AR2020_REG_VALUE_16BIT},
    {0x41EA, 0x0041, AR2020_REG_VALUE_16BIT},
    {0x41EC, 0x80F3, AR2020_REG_VALUE_16BIT},
    {0x41EE, 0xF213, AR2020_REG_VALUE_16BIT},
    {0x41F0, 0x00F0, AR2020_REG_VALUE_16BIT},
    {0x41F2, 0x13B8, AR2020_REG_VALUE_16BIT},
    {0x41F4, 0xF04C, AR2020_REG_VALUE_16BIT},
    {0x41F6, 0x9FF0, AR2020_REG_VALUE_16BIT},
    {0x41F8, 0x00B7, AR2020_REG_VALUE_16BIT},
    {0x41FA, 0xF006, AR2020_REG_VALUE_16BIT},
    {0x41FC, 0x0035, AR2020_REG_VALUE_16BIT},
    {0x41FE, 0x10AF, AR2020_REG_VALUE_16BIT},
    {0x4200, 0x3003, AR2020_REG_VALUE_16BIT},
    {0x4202, 0x30C0, AR2020_REG_VALUE_16BIT},
    {0x4204, 0xB2F0, AR2020_REG_VALUE_16BIT},
    {0x4206, 0x01B5, AR2020_REG_VALUE_16BIT},
    {0x4208, 0xF001, AR2020_REG_VALUE_16BIT},
    {0x420A, 0x85F0, AR2020_REG_VALUE_16BIT},
    {0x420C, 0x0292, AR2020_REG_VALUE_16BIT},
    {0x420E, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x4210, 0x9A8B, AR2020_REG_VALUE_16BIT},
    {0x4212, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x4214, 0x9997, AR2020_REG_VALUE_16BIT},
    {0x4216, 0xF007, AR2020_REG_VALUE_16BIT},
    {0x4218, 0xB6F0, AR2020_REG_VALUE_16BIT},
    {0x421A, 0x0020, AR2020_REG_VALUE_16BIT},
    {0x421C, 0x5830, AR2020_REG_VALUE_16BIT},
    {0x421E, 0xC040, AR2020_REG_VALUE_16BIT},
    {0x4220, 0x1282, AR2020_REG_VALUE_16BIT},
    {0x4222, 0xF005, AR2020_REG_VALUE_16BIT},
    {0x4224, 0x9CF0, AR2020_REG_VALUE_16BIT},
    {0x4226, 0x01B2, AR2020_REG_VALUE_16BIT},
    {0x4228, 0xF008, AR2020_REG_VALUE_16BIT},
    {0x422A, 0xB8F0, AR2020_REG_VALUE_16BIT},
    {0x422C, 0x0799, AR2020_REG_VALUE_16BIT},
    {0x422E, 0xF005, AR2020_REG_VALUE_16BIT},
    {0x4230, 0x98F0, AR2020_REG_VALUE_16BIT},
    {0x4232, 0x0296, AR2020_REG_VALUE_16BIT},
    {0x4234, 0xA2F0, AR2020_REG_VALUE_16BIT},
    {0x4236, 0x00A2, AR2020_REG_VALUE_16BIT},
    {0x4238, 0xF008, AR2020_REG_VALUE_16BIT},
    {0x423A, 0x9DF0, AR2020_REG_VALUE_16BIT},
    {0x423C, 0x02A1, AR2020_REG_VALUE_16BIT},
    {0x423E, 0xF01F, AR2020_REG_VALUE_16BIT},
    {0x4240, 0x1009, AR2020_REG_VALUE_16BIT},
    {0x4242, 0x2220, AR2020_REG_VALUE_16BIT},
    {0x4244, 0x0808, AR2020_REG_VALUE_16BIT},
    {0x4246, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x4248, 0x3600, AR2020_REG_VALUE_16BIT},
    {0x424A, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x424C, 0x88F0, AR2020_REG_VALUE_16BIT},
    {0x424E, 0x0788, AR2020_REG_VALUE_16BIT},
    {0x4250, 0x3600, AR2020_REG_VALUE_16BIT},
    {0x4252, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x4254, 0x83F0, AR2020_REG_VALUE_16BIT},
    {0x4256, 0x0290, AR2020_REG_VALUE_16BIT},
    {0x4258, 0xF016, AR2020_REG_VALUE_16BIT},
    {0x425A, 0x8BF0, AR2020_REG_VALUE_16BIT},
    {0x425C, 0x11A3, AR2020_REG_VALUE_16BIT},
    {0x425E, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x4260, 0xA3F0, AR2020_REG_VALUE_16BIT},
    {0x4262, 0x089D, AR2020_REG_VALUE_16BIT},
    {0x4264, 0xF002, AR2020_REG_VALUE_16BIT},
    {0x4266, 0xA1F0, AR2020_REG_VALUE_16BIT},
    {0x4268, 0x20A1, AR2020_REG_VALUE_16BIT},
    {0x426A, 0xF006, AR2020_REG_VALUE_16BIT},
    {0x426C, 0x4300, AR2020_REG_VALUE_16BIT},
    {0x426E, 0xF049, AR2020_REG_VALUE_16BIT},
    {0x4270, 0x4014, AR2020_REG_VALUE_16BIT},
    {0x4272, 0x8B8E, AR2020_REG_VALUE_16BIT},
    {0x4274, 0x9DF0, AR2020_REG_VALUE_16BIT},
    {0x4276, 0x0802, AR2020_REG_VALUE_16BIT},
    {0x4278, 0x02F0, AR2020_REG_VALUE_16BIT},
    {0x427A, 0x00A6, AR2020_REG_VALUE_16BIT},
    {0x427C, 0xF013, AR2020_REG_VALUE_16BIT},
    {0x427E, 0xB283, AR2020_REG_VALUE_16BIT},
    {0x4280, 0x9C36, AR2020_REG_VALUE_16BIT},
    {0x4282, 0x00F0, AR2020_REG_VALUE_16BIT},
    {0x4284, 0x0636, AR2020_REG_VALUE_16BIT},
    {0x4286, 0x009C, AR2020_REG_VALUE_16BIT},
    {0x4288, 0xF008, AR2020_REG_VALUE_16BIT},
    {0x428A, 0x8BF0, AR2020_REG_VALUE_16BIT},
    {0x428C, 0x0083, AR2020_REG_VALUE_16BIT},
    {0x4290, 0x0630, AR2020_REG_VALUE_16BIT},
    {0x4292, 0x18F0, AR2020_REG_VALUE_16BIT},
    {0x4294, 0x02A3, AR2020_REG_VALUE_16BIT},
    {0x4296, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x4298, 0xA3F0, AR2020_REG_VALUE_16BIT},
    {0x429A, 0x0243, AR2020_REG_VALUE_16BIT},
    {0x429C, 0x00F0, AR2020_REG_VALUE_16BIT},
    {0x429E, 0x049D, AR2020_REG_VALUE_16BIT},
    {0x42A0, 0xF078, AR2020_REG_VALUE_16BIT},
    {0x42A2, 0x3018, AR2020_REG_VALUE_16BIT},
    {0x42A4, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x42A6, 0x9D82, AR2020_REG_VALUE_16BIT},
    {0x42A8, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x42AA, 0x9030, AR2020_REG_VALUE_16BIT},
    {0x42AC, 0xC0F0, AR2020_REG_VALUE_16BIT},
    {0x42AE, 0x1130, AR2020_REG_VALUE_16BIT},
    {0x42B0, 0xC0F0, AR2020_REG_VALUE_16BIT},
    {0x42B2, 0x0082, AR2020_REG_VALUE_16BIT},
    {0x42B4, 0xF001, AR2020_REG_VALUE_16BIT},
    {0x42B6, 0x1009, AR2020_REG_VALUE_16BIT},
    {0x42B8, 0xF02A, AR2020_REG_VALUE_16BIT},
    {0x42BA, 0xA2F0, AR2020_REG_VALUE_16BIT},
    {0x42BC, 0x00A2, AR2020_REG_VALUE_16BIT},
    {0x42BE, 0x3018, AR2020_REG_VALUE_16BIT},
    {0x42C0, 0xF007, AR2020_REG_VALUE_16BIT},
    {0x42C2, 0x9DF0, AR2020_REG_VALUE_16BIT},
    {0x42C4, 0x1C8C, AR2020_REG_VALUE_16BIT},
    {0x42C6, 0xF005, AR2020_REG_VALUE_16BIT},
    {0x42C8, 0x301F, AR2020_REG_VALUE_16BIT},
    {0x42CA, 0x216D, AR2020_REG_VALUE_16BIT},
    {0x42CC, 0x0A51, AR2020_REG_VALUE_16BIT},
    {0x42CE, 0x1FEA, AR2020_REG_VALUE_16BIT},
    {0x42D0, 0x8640, AR2020_REG_VALUE_16BIT},
    {0x42D2, 0xE29F, AR2020_REG_VALUE_16BIT},
    {0x42D4, 0xF009, AR2020_REG_VALUE_16BIT},
    {0x42D6, 0x0005, AR2020_REG_VALUE_16BIT},
    {0x42D8, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x42DA, 0x30C0, AR2020_REG_VALUE_16BIT},
    {0x42DC, 0xF001, AR2020_REG_VALUE_16BIT},
    {0x42DE, 0x83F0, AR2020_REG_VALUE_16BIT},
    {0x42E0, 0x0036, AR2020_REG_VALUE_16BIT},
    {0x42E2, 0x00F0, AR2020_REG_VALUE_16BIT},
    {0x42E4, 0x0087, AR2020_REG_VALUE_16BIT},
    {0x42E6, 0xF007, AR2020_REG_VALUE_16BIT},
    {0x42E8, 0x87F0, AR2020_REG_VALUE_16BIT},
    {0x42EA, 0x0036, AR2020_REG_VALUE_16BIT},
    {0x42EC, 0xC0F0, AR2020_REG_VALUE_16BIT},
    {0x42EE, 0x0000, AR2020_REG_VALUE_16BIT},
    {0x42F0, 0x0DF0, AR2020_REG_VALUE_16BIT},
    {0x42F2, 0x0000, AR2020_REG_VALUE_16BIT},
    {0x42F4, 0x05F0, AR2020_REG_VALUE_16BIT},
    {0x42F6, 0x0030, AR2020_REG_VALUE_16BIT},
    {0x42F8, 0xC0F0, AR2020_REG_VALUE_16BIT},
    {0x42FA, 0x0183, AR2020_REG_VALUE_16BIT},
    {0x42FC, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x42FE, 0x3600, AR2020_REG_VALUE_16BIT},
    {0x4300, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x4302, 0x87F0, AR2020_REG_VALUE_16BIT},
    {0x4304, 0x0787, AR2020_REG_VALUE_16BIT},
    {0x4306, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x4308, 0x36C0, AR2020_REG_VALUE_16BIT},
    {0x430A, 0xF000, AR2020_REG_VALUE_16BIT},
    {0x430C, 0x000F, AR2020_REG_VALUE_16BIT},
    {0x430E, 0xF42A, AR2020_REG_VALUE_16BIT},
    {0x4310, 0x4180, AR2020_REG_VALUE_16BIT},
    {0x4312, 0x1300, AR2020_REG_VALUE_16BIT},
    {0x4314, 0x9FF0, AR2020_REG_VALUE_16BIT},
    {0x4316, 0x00E0, AR2020_REG_VALUE_16BIT},
    {0x4318, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x431A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x431C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x431E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4320, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4322, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4324, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4326, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4328, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x432A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x432C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x432E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4330, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4332, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4334, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4336, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4338, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x433A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x433C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x433E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4340, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4342, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4344, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4346, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4348, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x434A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x434C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x434E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4350, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4352, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4354, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4356, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4358, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x435A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x435C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x435E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4360, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4362, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4364, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4366, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4368, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x436A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x436C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x436E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4370, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4372, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4374, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4376, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4378, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x437A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x437C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x437E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4380, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4382, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4384, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4386, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4388, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x438A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x438C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x438E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4390, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4392, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4394, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4396, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4398, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x439A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x439C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x439E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43A0, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43A2, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43A4, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43A6, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43A8, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43AA, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43AC, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43AE, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43B0, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43B2, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43B4, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43B6, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43B8, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43BA, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43BC, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43BE, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43C0, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43C2, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43C4, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43C6, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43C8, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43CA, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43CC, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43CE, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43D0, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43D2, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43D4, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43D6, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43D8, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43DA, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43DC, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43DE, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43E0, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43E2, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43E4, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43E6, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43E8, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43EA, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43EC, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43EE, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43F0, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43F2, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43F4, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43F6, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43F8, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43FA, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43FC, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x43FE, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4400, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4402, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4404, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4406, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4408, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x440A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x440C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x440E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4410, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4412, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4414, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4416, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4418, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x441A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x441C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x441E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4420, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4422, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4424, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4426, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4428, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x442A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x442C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x442E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4430, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4432, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4434, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4436, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4438, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x443A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x443C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x443E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4440, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4442, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4444, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4446, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4448, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x444A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x444C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x444E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4450, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4452, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4454, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4456, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4458, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x445A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x445C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x445E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4460, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4462, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4464, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4466, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4468, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x446A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x446C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x446E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4470, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4472, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4474, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4476, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4478, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x447A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x447C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x447E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4480, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4482, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4484, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4486, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4488, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x448A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x448C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x448E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4490, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4492, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4494, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4496, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x4498, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x449A, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x449C, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x449E, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x44A0, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x44A2, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x44A4, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x44A6, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x44A8, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x44AA, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x44AC, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x44AE, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x44B0, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x44B2, 0xE0E0, AR2020_REG_VALUE_16BIT},
    {0x44B4, 0xE0E0, AR2020_REG_VALUE_16BIT},
    /* --- END TIMING ANALOG RECOMMEND POR --- */
    { REG_DELAY, 1000,   AR2020_REG_VALUE_16BIT },
    /* --- ANALOG RECOMMENDED SETTING --- */
    /* --- ANALOG RECOMMENDED SETTING --- */
    /* --- ANALOG RECOMMENDED SETTING --- */

    { 0x44BA, 0x0050, AR2020_REG_VALUE_16BIT },    /* [0x44BA] DAC_LD_4_5   = 0x0050   (ecl for lcg = 72, hcg_fsc = 0) */
    { 0x44BC, 0xBCAA, AR2020_REG_VALUE_16BIT },    /* [0x44BC] DAC_LD_6_7   = 0xBCAA */
    { 0x44C0, 0x4070, AR2020_REG_VALUE_16BIT },    /* [0x44C0] DAC_LD_10_11 = 0x4070   (txlo1_clk_gate_en=1, pnc_ibias_lcg=112) */
    { 0x44C4, 0x04D0, AR2020_REG_VALUE_16BIT },    /* [0x44C4] DAC_LD_14_15 = 0x04D0   (ecl for hcg = 80) */
    { 0x44C6, 0x17E2, AR2020_REG_VALUE_16BIT },    /* [0x44C6] DAC_LD_16_17 = 0x17E2   (adc_pwedn_en=1, azbias_ctrl=7) */
    { 0x44C8, 0xEA43, AR2020_REG_VALUE_16BIT },    /* [0x44C8] DAC_LD_18_19 = 0xEA43   (rs_hi for lcg = 10, for hcg low gain = 4) */
    { 0x44CA, 0x000E, AR2020_REG_VALUE_16BIT },    /* [0x44CA] DAC_LD_20_21 = 0x000E   (pcn_ibias_hcg = 0) */
    { 0x44CC, 0x7777, AR2020_REG_VALUE_16BIT },    /* [0x44CC] DAC_LD_22_23 = 0x7777   (txlo level = 0x7777) */
    { 0x44CE, 0x8BA4, AR2020_REG_VALUE_16BIT },    /* [0x44CE] DAC_LD_24_25 = 0x8BA4   (tx hi = 4, dcg_hi = 10, VAA = 3.6V) */
    { 0x44D0, 0x1735, AR2020_REG_VALUE_16BIT },    /* [0x44D0] DAC_LD_26_27 = 0x1735   (pnc_disable = 0, rampbuf_sel = 1) */
    { 0x44D2, 0x0B87, AR2020_REG_VALUE_16BIT },    /* [0x44D2] DAC_LD_28_29 = 0x0B87   (rs_hi_cloop_en = 1, txlo_en_1 = 1) */
    { 0x44D4, 0x0000, AR2020_REG_VALUE_16BIT },    /* [0x44D4] DAC_LD_30_31 = 0x0000   (pnc_ibias_hcg_off = 0) */
    { 0x44D6, 0xF206, AR2020_REG_VALUE_16BIT },    /* [0x44D6] DAC_LD_32_33 = 0xF206   (dcg_vaa_en = 1) */
    { 0x44D8, 0xAAFA, AR2020_REG_VALUE_16BIT },    /* [0x44D8] DAC_LD_34_35 = 0xAAFA   (clk_div_tx = 2, cap_sel = 2) */
    { 0x44DA, 0xE001, AR2020_REG_VALUE_16BIT },    /* [0x44DA] DAC_LD_36_37 = 0xE001   (pnc_sf_lcg = 7) */
    { 0x44DE, 0x9BBC, AR2020_REG_VALUE_16BIT },    /* [0x44DE] DAC_LD_40_41 = 0x9BBC   (rst_under = 60, ramp_delay = 27) */
    { 0x44E0, 0x283C, AR2020_REG_VALUE_16BIT },    /* [0x44E0] DAC_LD_42_43 = 0x283C   (sig_under = 60, rst_over = 40) */
    { 0x44E2, 0x2821, AR2020_REG_VALUE_16BIT },    /* [0x44E2] DAC_LD_44_45 = 0x2821   (sig_over = 40, reduce_colsel_en = 1) */
    { 0x44E4, 0x8000, AR2020_REG_VALUE_16BIT },    /* [0x44E4] DAC_LD_46_47 = 0x8000 */
    { 0x44E6, 0x503F, AR2020_REG_VALUE_16BIT },    /* [0x44E6] DAC_LD_48_49 = 0x503F   (rs_hi_hcg_high_gain = 6) */
    { 0x32A4, 0x0000, AR2020_REG_VALUE_16BIT },    /* [0x32A4] RESERVED_MFR_32A4 = 0x0000   (crm on) */
    { 0x328E, 0x0004, AR2020_REG_VALUE_16BIT },    /* [0x328E] ADDR_CTRL         = 0x0004   (integration_update_next_frame = 1) */
    { 0x333C, 0x0001, AR2020_REG_VALUE_16BIT },    /* [0x333C] DYNAMIC_CTRL      = 0x0001   (of_init = 1) */
  
    { 0x301A, 0x0000, AR2020_REG_VALUE_16BIT },    /* Unlock  */
    { 0x3600, 0x94DF, AR2020_REG_VALUE_16BIT },    /* [0x3600] RESERVED_MFR_3600 = 0x94DF   (Enable fdoc) */
    { 0x3616, 0x0000, AR2020_REG_VALUE_16BIT },    /* [0x3616] FDOC_CTRL2 = 0x0000   (Disable fdoc_bw_mode_en) */
    { 0x3700, 0x0001, AR2020_REG_VALUE_16BIT },    /* [0x3700] PIX_DEF_ID = 0x0001   (Enable pixel defect) */
    { 0x3980, 0x0003, AR2020_REG_VALUE_16BIT },    /* [0x3980] PIX_DEF_CORR = 0x0003   (Enable pixel defect) */
    { 0x36C0, 0x0001, AR2020_REG_VALUE_16BIT },    /* [0x36C0] DIGITAL_GAIN_CTRL = 0x0001   (Enable dither) */
    { 0x36DE, 0x002A, AR2020_REG_VALUE_16BIT },    /* [0x36DE] DATA_PEDESTAL1 = 0x002A   (Set pedestal = 42) */
    { 0x301A, 0x0008, AR2020_REG_VALUE_16BIT },    /* Lock  */
    /* SRGB Full resolution  */
    { 0x3060, 0x0000, AR2020_REG_VALUE_16BIT },    /* [0x3060] GAIN_TABLE_CTRL = 0x0000  */
    { 0x3982, 0xAC70, AR2020_REG_VALUE_16BIT },    /* [0x3982] PIX_DEF_LUT_DATA[0] = 0xAC70 */
    { 0x3984, 0xFA98, AR2020_REG_VALUE_16BIT },    /* [0x3984] PIX_DEF_LUT_DATA[1] = 0xFA98 */
    { 0x3986, 0xFC3F, AR2020_REG_VALUE_16BIT },    /* [0x3986] PIX_DEF_LUT_DATA[2] = 0xFC3F */
    { 0x3988, 0xAC70, AR2020_REG_VALUE_16BIT },    /* [0x3988] PIX_DEF_LUT_DATA[3] = 0xAC70 */
    { 0x398A, 0xFA98, AR2020_REG_VALUE_16BIT },    /* [0x398A] PIX_DEF_LUT_DATA[4] = 0xFA98 */
    { 0x398C, 0xFC3F, AR2020_REG_VALUE_16BIT },    /* [0x398C] PIX_DEF_LUT_DATA[5] = 0xFC3F */
    { 0x3980, 0x0003, AR2020_REG_VALUE_16BIT },    /* [0x3980] PIX_DEF_CORR = 0x0003   (Enable pixel defect correction) */

    { REG_DELAY, 1000,   AR2020_REG_VALUE_16BIT },
    { 0x3060, 0xFF01, AR2020_REG_VALUE_16BIT },    /* [0x3060] GAIN_TABLE_CTRL = 0xFF01 */
    /* --- END ANALOG RECOMMENDED SETTING --- */

    // { 0x3340, 0x0800, AR2020_REG_VALUE_16BIT },    /* [0x3340] OTPM_USER_POWERDOWN bit = 0x0800 */
    // { 0x3340, 0x1000, AR2020_REG_VALUE_16BIT },    /* [0x3340] OTPM_REGULATOR_PD bit  = 0x1000 */

    { REG_NULL, 0x0000, AR2020_REG_VALUE_16BIT }
};

/* Supported modes */
static const struct ar2020_mode supported_modes[] = {
    {
        .width = 5120,
        .height = 3840,
        .max_fps = { .numerator = 100, .denominator = 511 },  // 7.5 FPS
        .hts_def = 0xFFF0,  /* LINE_LENGTH_PCK = 21104 */
        .vts_def = 0x1BC4,  /* FRAME_LENGTH_LINES = 3854 */
        .exp_def = 0x0003 + 100,  /* Độ phơi sáng so với frame ảnh, càng to phơi sáng càng tốt, càng nhỏ càng tối COARSE_INTEGRATION_TIME = FRAME_LENGTH_LINES  - */ 
        .reg_list = MIPI_2lane__5120x3840_Linear_7p5fps,
    }
};

static const char * const ar2020_test_pattern_menu[] = {
	"Disabled",
	"Solid Color",
	"Color Bars",
	"Fade to Grey Bars",
	"PN9 Link Integrity",
	"100% Color Tile",
    "Marching 1s"
};

/* Register Access Functions */
static int ar2020_read_reg(struct i2c_client *client, u16 reg, u8 len, u32 *val)
{
    struct i2c_msg msgs[2];
    u8 addr_buf[2] = { reg >> 8, reg & 0xFF };
    u8 data_buf[2] = { 0 };
    int ret;

    msgs[0].addr = client->addr;
    msgs[0].flags = 0;
    msgs[0].len = 2;
    msgs[0].buf = addr_buf;

    msgs[1].addr = client->addr;
    msgs[1].flags = I2C_M_RD;
    msgs[1].len = len;
    msgs[1].buf = data_buf;

    ret = i2c_transfer(client->adapter, msgs, 2);
    if (ret != 2) {
        dev_err(&client->dev, "Failed to read reg 0x%04x: %d\n", reg, ret);
        return -EIO;
    }

    *val = (len == AR2020_REG_VALUE_16BIT) ? (data_buf[0] << 8) | data_buf[1] : data_buf[0];
    return 0;
}

static int ar2020_write_reg(struct i2c_client *client, u16 reg, u8 len, u16 val)
{
    struct i2c_msg msg;
    u8 buf[4];
    int ret;

    buf[0] = reg >> 8;
    buf[1] = reg & 0xFF;
    if (len == AR2020_REG_VALUE_08BIT) {
        buf[2] = val & 0xFF;
    } else {
        buf[2] = val >> 8;
        buf[3] = val & 0xFF;
    }

    msg.addr = client->addr;
    msg.flags = 0;
    msg.len = (len == AR2020_REG_VALUE_08BIT) ? 3 : 4;
    msg.buf = buf;

    ret = i2c_transfer(client->adapter, &msg, 1);
    if (ret != 1) {
        dev_err(&client->dev, "Failed to write reg 0x%04x: %d\n", reg, ret);
        return -EIO;
    }
    return 0;
}

static int ar2020_write_array(struct i2c_client *client, const struct regval *regs)
{
    int ret = 0;
    while (regs->addr != REG_NULL) {
        if (regs->addr == REG_DELAY) {
            usleep_range(regs->val, regs->val + 100);
        } else {
            ret = ar2020_write_reg(client, regs->addr, regs->bits, regs->val);
            if (ret)
                return ret;
        }
        regs++;
    }
    return 0;
}

/* Helper function to apply custom register settings */
static int ar2020_apply_custom_regs(struct ar2020 *ar2020)
{
    int ret = 0;
    for (int i = 0; i < AR2020_MAX_CUSTOM_REGS; i++) {
        if (ar2020->custom_regs_array[i].enabled) {
            ret = ar2020_write_reg(ar2020->client,
                                   ar2020->custom_regs_array[i].addr,
                                   ar2020->custom_regs_array[i].bits,
                                   ar2020->custom_regs_array[i].val);
            if (ret) {
                dev_err(&ar2020->client->dev,
                        "Failed to set custom reg 0x%04x to 0x%04x: %d\n",
                        ar2020->custom_regs_array[i].addr,
                        ar2020->custom_regs_array[i].val, ret);
                return ret;
            }
            dev_info(&ar2020->client->dev,
                     "Set custom reg 0x%04x = 0x%04x\n",
                     ar2020->custom_regs_array[i].addr,
                     ar2020->custom_regs_array[i].val);
        }
    }
    return 0;
}

/* Power Management */
static int __ar2020_power_on(struct ar2020 *ar2020)
{
    int ret;
    struct device *dev = &ar2020->client->dev;

    dev_info(dev, "ar2020 Calling PowerOn");

    ret = clk_set_rate(ar2020->xvclk, AR2020_XVCLK_FREQ);
    if (ret)
        dev_warn(dev, "Failed to set xvclk rate\n");
    ret = clk_prepare_enable(ar2020->xvclk);
    if (ret) {
        dev_err(dev, "Failed to enable xvclk\n");
        return ret;
    }

    ret = regulator_bulk_enable(AR2020_NUM_SUPPLIES, ar2020->supplies);
    if (ret) {
        dev_err(dev, "Failed to enable regulators\n");
        goto disable_clk;
    }

    if (!IS_ERR(ar2020->pwdn_gpio))
        gpiod_set_value(ar2020->pwdn_gpio, 1);
    if (!IS_ERR(ar2020->reset_gpio)) {
        gpiod_set_value(ar2020->reset_gpio, 1);
        usleep_range(6000, 8000);
        gpiod_set_value(ar2020->reset_gpio, 0);
    } else {
        usleep_range(12000, 16000);
    }

    dev_info(dev, "ar2020 Done PowerOnStep Without ERROR");
    usleep_range(5000, 10000);
    return 0;

disable_clk:
    clk_disable_unprepare(ar2020->xvclk);
    return ret;
}

static void __ar2020_power_off(struct ar2020 *ar2020)
{
    if (!IS_ERR(ar2020->pwdn_gpio))
        gpiod_set_value(ar2020->pwdn_gpio, 0);
    if (!IS_ERR(ar2020->reset_gpio))
        gpiod_set_value(ar2020->reset_gpio, 0);
    regulator_bulk_disable(AR2020_NUM_SUPPLIES, ar2020->supplies);
    clk_disable_unprepare(ar2020->xvclk);
}

/* Sensor Initialization */
static int ar2020_check_sensor_id(struct ar2020 *ar2020)
{
    u32 id = 0;
    int ret;

    ret = ar2020_read_reg(ar2020->client, AR2020_REG_CHIP_ID, AR2020_REG_VALUE_16BIT, &id);
    if (ret) {
        dev_err(&ar2020->client->dev, "Failed to read chip ID\n");
        return ret;
    }
    if (id != CHIP_ID) {
        dev_err(&ar2020->client->dev, "Wrong chip ID: 0x%04x (expected 0x%04x)\n", id, CHIP_ID);
        return -ENODEV;
    }
    dev_info(&ar2020->client->dev, "Detected AR2020 chip ID: 0x%04x\n", id);
    return 0;
}

/* Streaming */
static int __ar2020_start_stream(struct ar2020 *ar2020)
{
    int ret;
    u32 val;

    dev_info(&ar2020->client->dev, "Starting stream\n");
    ret = ar2020_write_array(ar2020->client, ar2020->cur_mode->reg_list);
    if (ret) {
        dev_err(&ar2020->client->dev, "Failed to write register array: %d\n", ret);
        return ret;
    }

    /* Xác nhận MIPI 2-lane */
    ret = ar2020_read_reg(ar2020->client, 0x0114, AR2020_REG_VALUE_08BIT, &val);
    if (ret) {
        dev_err(&ar2020->client->dev, "Failed to read CSI_LANE_MODE: %d\n", ret);
        return ret;
    }
    if (val != 0x01) {
        dev_err(&ar2020->client->dev, "CSI_LANE_MODE is 0x%02x, expected 0x01\n", val);
    } else {
        dev_info(&ar2020->client->dev, "CSI_LANE_MODE confirmed as 2-lane (0x01)\n");
    }

    /* Áp dụng các điều khiển V4L2 trước khi stream */
    ret = __v4l2_ctrl_handler_setup(&ar2020->ctrl_handler);
    if (ret) {
        dev_err(&ar2020->client->dev, "Failed to setup controls: %d\n", ret);
        return ret;
    }

    /* Apply custom register settings */
    ret = ar2020_apply_custom_regs(ar2020);
    if (ret) {
        dev_err(&ar2020->client->dev, "Failed to apply custom registers: %d\n", ret);
        return ret;
    }    

    ret = ar2020_write_reg(ar2020->client, AR2020_REG_CTRL_MODE,
                           AR2020_REG_VALUE_08BIT, AR2020_MODE_STREAMING);
    if (ret) {
        dev_err(&ar2020->client->dev, "Failed to start streaming: %d\n", ret);
        return ret;
    }

    usleep_range(10000, 20000);
    ret = ar2020_read_reg(ar2020->client, 0x0005, AR2020_REG_VALUE_08BIT, &val);
    if (ret) {
        dev_err(&ar2020->client->dev, "Failed to read FRAME_COUNT\n");
        return ret;
    }
    dev_info(&ar2020->client->dev, "FRAME_COUNT after streaming: 0x%02x\n", val);

    return 0;
}

static int __ar2020_stop_stream(struct ar2020 *ar2020)
{
    return ar2020_write_reg(ar2020->client, AR2020_REG_CTRL_MODE,
                            AR2020_REG_VALUE_08BIT, AR2020_MODE_SW_STANDBY);
}

static int ar2020_s_stream(struct v4l2_subdev *sd, int enable)
{
    struct ar2020 *ar2020 = to_ar2020(sd);
    int ret = 0;

    mutex_lock(&ar2020->mutex);
    if (ar2020->streaming == enable)
        goto unlock;

    if (enable) {
        ret = pm_runtime_get_sync(&ar2020->client->dev);
        if (ret < 0) {
            pm_runtime_put_noidle(&ar2020->client->dev);
            goto unlock;
        }
        ret = __ar2020_start_stream(ar2020);
        if (ret) {
            dev_err(&ar2020->client->dev, "Stream start failed: %d\n", ret);
            pm_runtime_put(&ar2020->client->dev);
            goto unlock;
        }
        dev_info(&ar2020->client->dev, "Stream started\n");
    } else {
        ret = __ar2020_stop_stream(ar2020);
        if (ret)
            dev_err(&ar2020->client->dev, "Stream stop failed: %d\n", ret);
        pm_runtime_put(&ar2020->client->dev);
        dev_info(&ar2020->client->dev, "Stream stopped\n");
    }
    ar2020->streaming = enable;

unlock:
    mutex_unlock(&ar2020->mutex);
    return ret;
}

/* V4L2 Controls */
static int ar2020_s_ctrl(struct v4l2_ctrl *ctrl)
{
    struct ar2020 *ar2020 =
        container_of(ctrl->handler, struct ar2020, ctrl_handler);
    struct i2c_client *client = ar2020->client;
    int ret = 0;
    u16 tp_mode = 0;

    /* Nếu sensor chưa được bật (power off), không làm gì */
    if (!pm_runtime_get_if_in_use(&client->dev))
        return 0;

    switch (ctrl->id) {
    case V4L2_CID_EXPOSURE:
        ret = ar2020_write_reg(client, 0x0202, /* COARSE_INTEGRATION_TIME */
                               AR2020_REG_VALUE_16BIT, ctrl->val);
        if (ret)
            dev_err(&client->dev, "Failed to set exposure: %d\n", ret);
        break;

    case V4L2_CID_ANALOGUE_GAIN:
        ret = ar2020_write_reg(client, 0x3062, /* ANALOGUE_GAIN */
                               AR2020_REG_VALUE_16BIT, ctrl->val);
        if (ret)
            dev_err(&client->dev, "Failed to set gain: %d\n", ret);
        break;

    case V4L2_CID_VBLANK:
        ret = ar2020_write_reg(client, 0x0340, /* FRAME_LENGTH_LINES */
                               AR2020_REG_VALUE_16BIT,
                               ar2020->cur_mode->height + ctrl->val);
        if (ret)
            dev_err(&client->dev, "Failed to set vblank: %d\n", ret);
        break;

    case V4L2_CID_HBLANK:
        /* HBLANK là read-only, không thiết lập gì thêm. */
        break;

    case V4L2_CID_PIXEL_RATE:
        /* PIXEL_RATE cũng read-only. */
        break;

    case V4L2_CID_TEST_PATTERN:
        if (ctrl->val == 0) {
            tp_mode = 0x0000; // Disable
        } else if (ctrl->val == 6) {
            tp_mode = 0x0100; // Marching 1s test pattern
        } else {
            tp_mode = ctrl->val & 0x7; // Only bits 2:0, no bit 8
        }
        ret = ar2020_write_reg(client, 0x0600, AR2020_REG_VALUE_16BIT, tp_mode);
        if (ret)
            break;
        if (ctrl->val == 1) {
            ar2020_write_reg(client, 0x0602, AR2020_REG_VALUE_16BIT, 0x03FF); // TEST_DATA_RED
            // Thêm các giá trị khác nếu cần
        }
        break;

    case V4L2_CID_AR2020_SET_REGISTER:
    {
        const char *str = ctrl->p_new.p_char;
        u16 addr, val;
        u8 bits;
        int index = -1;

        /* Skip if string is empty or NULL */
        if (!str || !str[0]) {
            dev_dbg(&client->dev, "Skipping empty custom register control\n");
            break;
        }

        /* Parse format: 0xADDR=0xVALUE:BITS */
        if (sscanf(str, "0x%hx=0x%hx:%hhu", &addr, &val, &bits) != 3) {
            dev_err(&client->dev, "Invalid register format: %s (expected 0xADDR=0xVALUE:BITS)\n", str);
            ret = -EINVAL;
            break;
        }

        if (bits != 8 && bits != 16) {
            dev_err(&client->dev, "Invalid bit width: %u (must be 8 or 16)\n", bits);
            ret = -EINVAL;
            break;
        }

        for (int i = 0; i < AR2020_MAX_CUSTOM_REGS; i++) {
            if (!ar2020->custom_regs_array[i].enabled) {
                index = i;
                break;
            }
            if (ar2020->custom_regs_array[i].addr == addr) {
                index = i;
                break;
            }
        }

        if (index < 0) {
            dev_err(&client->dev, "No space for new custom register\n");
            ret = -ENOMEM;
            break;
        }

        ar2020->custom_regs_array[index].addr = addr;
        ar2020->custom_regs_array[index].val = val;
        ar2020->custom_regs_array[index].bits = (bits == 8) ? AR2020_REG_VALUE_08BIT : AR2020_REG_VALUE_16BIT;
        ar2020->custom_regs_array[index].enabled = true;

        dev_info(&client->dev, "Stored custom reg 0x%04x = 0x%04x, %d-bit\n", addr, val, bits);
        break;
    }

    case V4L2_CID_AR2020_CLEAR_CUSTOM_REGS:
    {
        const char *str = ctrl->p_new.p_char;
        u16 addr;
        bool cleared = false;

        /* Skip if string is empty or NULL */
        if (!str || !str[0]) {
            dev_dbg(&client->dev, "Skipping empty clear custom registers control\n");
            break;
        }

        if (!strcmp(str, "all")) {
            for (int i = 0; i < AR2020_MAX_CUSTOM_REGS; i++) {
                ar2020->custom_regs_array[i].enabled = false;
            }
            dev_info(&client->dev, "Cleared all custom registers\n");
            cleared = true;
        } else if (sscanf(str, "0x%hx", &addr) == 1) {
            for (int i = 0; i < AR2020_MAX_CUSTOM_REGS; i++) {
                if (ar2020->custom_regs_array[i].enabled &&
                    ar2020->custom_regs_array[i].addr == addr) {
                    ar2020->custom_regs_array[i].enabled = false;
                    dev_info(&client->dev, "Cleared custom reg 0x%04x\n", addr);
                    cleared = true;
                    break;
                }
            }
        } else {
            dev_err(&client->dev, "Invalid clear format: %s (use 'all' or '0xADDR')\n", str);
            ret = -EINVAL;
            break;
        }

        if (!cleared && strcmp(str, "all")) {
            dev_warn(&client->dev, "No custom reg 0x%04x found to clear\n", addr);
        }
        break;
    }
    
    default:
        ret = -EINVAL;
        break;
    }

    pm_runtime_put(&client->dev);
    return ret;
}

static const struct v4l2_ctrl_ops ar2020_ctrl_ops = {
    .s_ctrl = ar2020_s_ctrl,
};

/* Subdev Operations */
static int ar2020_enum_mbus_code(struct v4l2_subdev *sd,
                                 struct v4l2_subdev_state *sd_state,
                                 struct v4l2_subdev_mbus_code_enum *code)
{
    if (code->index != 0)
        return -EINVAL;
    code->code = MEDIA_BUS_FMT_SBGGR10_1X10; // RAW10
    return 0;
}

// static int ar2020_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_state *sd_state,
//     struct v4l2_subdev_format *fmt)
// {
//     struct ar2020 *ar2020 = to_ar2020(sd);
//     const struct ar2020_mode *mode = ar2020->cur_mode;

//     dev_info(&ar2020->client->dev, "ar2020_get_fmt: Returning %dx%d\n", mode->width, mode->height);
//     fmt->format.width = mode->width;
//     fmt->format.height = mode->height;
//     fmt->format.code = MEDIA_BUS_FMT_SRGGB10_1X10; // RAW10, RGGB Bayer
//     fmt->format.field = V4L2_FIELD_NONE;
//     fmt->format.colorspace = V4L2_COLORSPACE_SRGB;
//     fmt->format.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
//     fmt->format.quantization = V4L2_QUANTIZATION_DEFAULT;
//     fmt->format.xfer_func = V4L2_XFER_FUNC_DEFAULT;
//     return 0;
// }

static int ar2020_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_state *sd_state,
    struct v4l2_subdev_format *fmt)
{
    struct ar2020 *ar2020 = to_ar2020(sd);
    const struct ar2020_mode *mode = ar2020->cur_mode;

    dev_info(&ar2020->client->dev, "ar2020_get_fmt called, pad=%d, which=%d\n",
    fmt->pad, fmt->which);
    dev_info(&ar2020->client->dev, "ar2020_get_fmt: Returning %dx%d, code=0x%x\n",
    mode->width, mode->height, MEDIA_BUS_FMT_SBGGR10_1X10);
    fmt->format.width = mode->width;
    fmt->format.height = mode->height;
    fmt->format.code = MEDIA_BUS_FMT_SBGGR10_1X10;
    fmt->format.field = V4L2_FIELD_NONE;
    fmt->format.colorspace = V4L2_COLORSPACE_SRGB;
    fmt->format.ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->format.colorspace);
    fmt->format.quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true,
                                fmt->format.colorspace,
                                fmt->format.ycbcr_enc);
    fmt->format.xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->format.colorspace);

    return 0;
}

static int ar2020_set_fmt(struct v4l2_subdev *sd,
                          struct v4l2_subdev_state *sd_state,
                          struct v4l2_subdev_format *fmt)
{
    struct ar2020 *ar2020 = to_ar2020(sd);

    if (fmt->format.width != ar2020->cur_mode->width ||
        fmt->format.height != ar2020->cur_mode->height)
        return -EINVAL;

    fmt->format.code = MEDIA_BUS_FMT_SBGGR10_1X10;
    fmt->format.field = V4L2_FIELD_NONE;
    return 0;
}

static int ar2020_get_selection(struct v4l2_subdev *sd,
    struct v4l2_subdev_state *state,
    struct v4l2_subdev_selection *sel)
{
    struct ar2020 *ar2020 = to_ar2020(sd);
    const struct ar2020_mode *mode = ar2020->cur_mode;

    if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
    return -EINVAL;

    switch (sel->target) {
    case V4L2_SEL_TGT_CROP_DEFAULT:
    case V4L2_SEL_TGT_CROP:
    case V4L2_SEL_TGT_CROP_BOUNDS:
    sel->r.left = 0;
    sel->r.top = 0;
    sel->r.width = mode->width;
    sel->r.height = mode->height;
    return 0;
    default:
    return -EINVAL;
    }
}

static int ar2020_initialize_controls(struct ar2020 *ar2020)
{
    struct v4l2_ctrl_handler *handler = &ar2020->ctrl_handler;
    const struct ar2020_mode *mode = ar2020->cur_mode;
    s64 exposure_max, vblank_def;
    u32 h_blank;
    int ret;

    ret = v4l2_ctrl_handler_init(handler, 8);
    if (ret)
        return ret;

    h_blank = mode->hts_def - mode->width;
    ar2020->hblank = v4l2_ctrl_new_std(handler, NULL, V4L2_CID_HBLANK,
                                       h_blank, h_blank, 1, h_blank);
    if (ar2020->hblank)
        ar2020->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;

    vblank_def = mode->vts_def - mode->height;
    ar2020->vblank = v4l2_ctrl_new_std(handler, &ar2020_ctrl_ops,
                                       V4L2_CID_VBLANK, vblank_def,
                                       AR2020_VTS_MAX - mode->height, 1, vblank_def);

    exposure_max = mode->vts_def - 4; // Ví dụ: 0x1BC4 - 4 = 7104
    ar2020->exposure = v4l2_ctrl_new_std(handler, &ar2020_ctrl_ops,
                                         V4L2_CID_EXPOSURE, AR2020_EXPOSURE_MIN,
                                         exposure_max, AR2020_EXPOSURE_STEP,
                                         mode->exp_def); // exp_def = 0x0003 + 100

    ar2020->anal_gain = v4l2_ctrl_new_std(handler, &ar2020_ctrl_ops,
                                          V4L2_CID_ANALOGUE_GAIN, AR2020_GAIN_MIN,
                                          AR2020_GAIN_MAX, AR2020_GAIN_STEP,
                                          AR2020_GAIN_DEFAULT);

    ar2020->pixel_rate = v4l2_ctrl_new_std(handler, &ar2020_ctrl_ops,
                                            V4L2_CID_PIXEL_RATE, PIXEL_RATE,
                                            PIXEL_RATE, 1, PIXEL_RATE);
    if (ar2020->pixel_rate)
        ar2020->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;

    ar2020->test_pattern = v4l2_ctrl_new_std_menu_items(handler,
                           &ar2020_ctrl_ops,
                           V4L2_CID_TEST_PATTERN,
                           ARRAY_SIZE(ar2020_test_pattern_menu) - 1,
                           0,
                           0,
                           ar2020_test_pattern_menu);

    ar2020->custom_regs = v4l2_ctrl_new_custom(handler, &(struct v4l2_ctrl_config) {
        .ops = &ar2020_ctrl_ops,
        .id = V4L2_CID_AR2020_SET_REGISTER,
        .name = "Set Custom Register",
        .type = V4L2_CTRL_TYPE_STRING,
        .flags = V4L2_CTRL_FLAG_WRITE_ONLY,
        .max = 32, /* Enough for "0xFFFF=0xFFFF,16" */
        .step = 1,
    }, NULL); 
                   
    ar2020->clear_custom_regs = v4l2_ctrl_new_custom(handler, &(struct v4l2_ctrl_config) {
        .ops = &ar2020_ctrl_ops,
        .id = V4L2_CID_AR2020_CLEAR_CUSTOM_REGS,
        .name = "Clear Custom Registers",
        .type = V4L2_CTRL_TYPE_STRING,
        .flags = V4L2_CTRL_FLAG_WRITE_ONLY,
        .max = 16, /* Enough for "all" or "0xFFFF" */
        .step = 1,
    }, NULL);

    if (handler->error) {
        ret = handler->error;
        v4l2_ctrl_handler_free(handler);
        return ret;
    }

    ar2020->subdev.ctrl_handler = handler;

    ret = ar2020_s_ctrl(ar2020->exposure);
    if (ret)
        dev_err(&ar2020->client->dev, "Failed to set default exposure\n");
    ret = ar2020_s_ctrl(ar2020->anal_gain);
    if (ret)
        dev_err(&ar2020->client->dev, "Failed to set default gain\n");

    return 0;
}

static const struct v4l2_subdev_video_ops ar2020_video_ops = {
    .s_stream = ar2020_s_stream,
};

static const struct v4l2_subdev_pad_ops ar2020_pad_ops = {
    .enum_mbus_code = ar2020_enum_mbus_code,
    .get_fmt = ar2020_get_fmt,
    .set_fmt = ar2020_set_fmt,
    .get_selection = ar2020_get_selection,
};

static const struct v4l2_subdev_ops ar2020_subdev_ops = {
    .video = &ar2020_video_ops,
    .pad = &ar2020_pad_ops,
};

/* Probe and Remove */
static int ar2020_probe(struct i2c_client *client)
{
    struct device *dev = &client->dev;
    struct ar2020 *ar2020;
    struct v4l2_subdev *sd;
    int ret;

    dev_info(dev, "AR2020 probe starting, I2C addr: 0x%02x\n", client->addr);

    ar2020 = devm_kzalloc(dev, sizeof(*ar2020), GFP_KERNEL);
    if (!ar2020) {
        dev_err(dev, "Failed to allocate memory for ar2020\n");
        return -ENOMEM;
    }

    ar2020->client = client;
    ar2020->cur_mode = &supported_modes[0]; // Mặc định full @ 7.5fps
    sd = &ar2020->subdev;
    v4l2_i2c_subdev_init(sd, client, &ar2020_subdev_ops);

    ar2020->xvclk = devm_clk_get(dev, "xvclk");
    if (IS_ERR(ar2020->xvclk)) {
        dev_err(dev, "Failed to get xvclk\n");
        return PTR_ERR(ar2020->xvclk);
    }

    ar2020->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
    ar2020->pwdn_gpio = devm_gpiod_get_optional(dev, "pwdn", GPIOD_OUT_LOW);

    for (int i = 0; i < AR2020_NUM_SUPPLIES; i++)
        ar2020->supplies[i].supply = ar2020_supply_names[i];
    ret = devm_regulator_bulk_get(dev, AR2020_NUM_SUPPLIES, ar2020->supplies);
    if (ret) {
        dev_err(dev, "Failed to get regulators\n");
        return ret;
    }

    mutex_init(&ar2020->mutex);

    /* Initialize custom registers array */
    for (int i = 0; i < AR2020_MAX_CUSTOM_REGS; i++)
        ar2020->custom_regs_array[i].enabled = false;    

    ret = ar2020_initialize_controls(ar2020);
    if (ret)
        goto err_destroy_mutex;

    ret = __ar2020_power_on(ar2020);
    if (ret)
        goto err_free_handler;

    ret = ar2020_check_sensor_id(ar2020);
    if (ret) {
        dev_err(dev, "Failed to detect AR2020 chip\n");
        goto err_power_off;
    }
    dev_info(dev, "AR2020 chip detected successfully\n");

    sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
    ar2020->pad.flags = MEDIA_PAD_FL_SOURCE;
    sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
    ret = media_entity_pads_init(&sd->entity, 1, &ar2020->pad);
    if (ret) {
        dev_err(dev, "Failed to init media entity: %d\n", ret);
        goto err_power_off;
    }
    dev_info(dev, "Media entity initialized successfully\n");

    ret = v4l2_async_register_subdev(sd);
    if (ret) {
        dev_err(dev, "Failed to register V4L2 subdev: %d\n", ret);
        goto err_clean_entity;
    }
    dev_info(dev, "AR2020 V4L2 subdev registered successfully\n");

    pm_runtime_set_active(dev);
    pm_runtime_enable(dev);
    pm_runtime_idle(dev);

    return 0;

err_clean_entity:
    media_entity_cleanup(&sd->entity);
err_power_off:
    __ar2020_power_off(ar2020);
err_free_handler:
    v4l2_ctrl_handler_free(&ar2020->ctrl_handler);
err_destroy_mutex:
    mutex_destroy(&ar2020->mutex);
    return ret;
}

static void ar2020_remove(struct i2c_client *client)
{
    struct v4l2_subdev *sd = i2c_get_clientdata(client);
    struct ar2020 *ar2020 = to_ar2020(sd);

    v4l2_async_unregister_subdev(sd);
    media_entity_cleanup(&sd->entity);
    v4l2_ctrl_handler_free(&ar2020->ctrl_handler);
    mutex_destroy(&ar2020->mutex);

    pm_runtime_disable(&client->dev);
    if (!pm_runtime_status_suspended(&client->dev))
        __ar2020_power_off(ar2020);
    pm_runtime_set_suspended(&client->dev);
}

static const struct of_device_id ar2020_of_match[] = {
    { .compatible = "onsemi,ar2020" },
    {},
};
MODULE_DEVICE_TABLE(of, ar2020_of_match);

static struct i2c_driver ar2020_i2c_driver = {
    .driver = {
        .name = AR2020_NAME,
        .of_match_table = ar2020_of_match,
    },
    .probe = ar2020_probe,
    .remove = ar2020_remove,
};

module_i2c_driver(ar2020_i2c_driver);

MODULE_DESCRIPTION("Onsemi AR2020 sensor driver for Raspberry Pi CM4");
MODULE_AUTHOR("Bao Bui");
MODULE_LICENSE("GPL");
